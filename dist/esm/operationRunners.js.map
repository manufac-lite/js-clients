{"version":3,"file":"operationRunners.js","sourceRoot":"","sources":["../../src/operationRunners.ts"],"names":[],"mappings":"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","sourcesContent":["import { filter, pipe, take, toPromise } from \"wonka\";\nimport type { BackgroundActionResult } from \"./BackgroundActionHandle.js\";\nimport { BackgroundActionHandle } from \"./BackgroundActionHandle.js\";\nimport type { FieldSelection } from \"./FieldSelection.js\";\nimport type { GadgetConnection } from \"./GadgetConnection.js\";\nimport type { AnyActionFunction } from \"./GadgetFunctions.js\";\nimport type { GadgetRecord, RecordShape } from \"./GadgetRecord.js\";\nimport { GadgetRecordList } from \"./GadgetRecordList.js\";\nimport type { AnyModelManager } from \"./ModelManager.js\";\nimport {\n  actionOperation,\n  actionResultOperation,\n  enqueueActionOperation,\n  findManyOperation,\n  findOneByFieldOperation,\n  findOneOperation,\n  globalActionOperation,\n} from \"./operationBuilders.js\";\nimport {\n  GadgetErrorGroup,\n  assertMutationSuccess,\n  assertNullableOperationSuccess,\n  assertOperationSuccess,\n  assertResponseSuccess,\n  disambiguateActionVariables,\n  disambiguateBulkActionVariables,\n  gadgetErrorFor,\n  get,\n  getNonUniqueDataError,\n  hydrateConnection,\n  hydrateRecord,\n  hydrateRecordArray,\n  setVariableOptionValues,\n} from \"./support.js\";\nimport type { ActionFunctionOptions, BaseFindOptions, EnqueueBackgroundActionOptions, FindManyOptions, VariablesOptions } from \"./types.js\";\n\nexport const findOneRunner = async <Shape extends RecordShape = any>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  id: string | undefined,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: BaseFindOptions | null,\n  throwOnEmptyData = true\n) => {\n  const plan = findOneOperation(operation, id, defaultSelection, modelApiIdentifier, options);\n  const response = await modelManager.connection.currentClient.query(plan.query, plan.variables).toPromise();\n  const assertSuccess = throwOnEmptyData ? assertOperationSuccess : assertNullableOperationSuccess;\n  const record = assertSuccess(response, [operation]);\n  return hydrateRecord<Shape>(response, record);\n};\n\nexport const findOneByFieldRunner = async <Shape extends RecordShape = any>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  fieldName: string,\n  fieldValue: string,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: BaseFindOptions | null\n) => {\n  const plan = findOneByFieldOperation(operation, fieldName, fieldValue, defaultSelection, modelApiIdentifier, options);\n  const response = await modelManager.connection.currentClient.query(plan.query, plan.variables).toPromise();\n  const connectionObject = assertOperationSuccess(response, [operation]);\n  const records = hydrateConnection<Shape>(response, connectionObject);\n\n  if (records.length > 1) {\n    throw getNonUniqueDataError(modelApiIdentifier, fieldName, fieldValue);\n  }\n\n  return records[0];\n};\n\nexport const findManyRunner = async <Shape extends RecordShape = any>(\n  modelManager: AnyModelManager,\n  operation: string,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: FindManyOptions,\n  throwOnEmptyData?: boolean\n) => {\n  const plan = findManyOperation(operation, defaultSelection, modelApiIdentifier, options);\n  const response = await modelManager.connection.currentClient.query(plan.query, plan.variables).toPromise();\n\n  let connectionObject;\n  if (throwOnEmptyData === false) {\n    // If this is a nullable operation, don't throw errors on empty\n    connectionObject = assertNullableOperationSuccess(response, [operation]);\n  } else {\n    // Otherwise, passthrough the `throwOnEmptyData` flag, to account for\n    // `findMany` (allows empty arrays) vs `findFirst` (no empty result) usage.\n    connectionObject = assertOperationSuccess(response, [operation], throwOnEmptyData);\n  }\n\n  const records = hydrateConnection<Shape>(response, connectionObject);\n  return GadgetRecordList.boot<Shape>(modelManager, records, { options, pageInfo: connectionObject.pageInfo });\n};\n\nexport interface ActionRunner {\n  (\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: true\n  ): Promise<any>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: false\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>[]>;\n\n  (\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: true\n  ): Promise<any[]>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: false\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>[]>;\n}\n\nexport const actionRunner: ActionRunner = async <Shape extends RecordShape = any>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  defaultSelection: FieldSelection | null,\n  modelApiIdentifier: string,\n  modelSelectionField: string,\n  isBulkAction: boolean,\n  variables: VariablesOptions,\n  options?: BaseFindOptions | null,\n  namespace?: string | null,\n  hasReturnType?: boolean | null\n) => {\n  const plan = actionOperation(\n    operation,\n    defaultSelection,\n    modelApiIdentifier,\n    modelSelectionField,\n    variables,\n    options,\n    namespace,\n    isBulkAction,\n    hasReturnType\n  );\n  const response = await modelManager.connection.currentClient.mutation(plan.query, plan.variables).toPromise();\n\n  // pass bulk responses through without any assertions since we can have a success: false response but still want\n  // to process it in a similar fashion since some of the records could have been processed\n  const dataPath = namespace ? [namespace, operation] : [operation];\n\n  if (!isBulkAction) {\n    const mutationTriple = assertMutationSuccess(response, dataPath);\n\n    return processActionResponse(defaultSelection, response, mutationTriple[modelSelectionField], hasReturnType);\n  } else {\n    const mutationTriple = get(response.data, dataPath);\n    const results =\n      mutationTriple[modelSelectionField] && defaultSelection\n        ? hydrateRecordArray<Shape>(response, mutationTriple[modelSelectionField])\n        : undefined;\n    if (mutationTriple.errors) {\n      const errors = mutationTriple.errors.map((error: any) => gadgetErrorFor(error));\n      throw new GadgetErrorGroup(errors, results);\n    }\n\n    return results;\n  }\n};\n\nconst processActionResponse = <Shape extends RecordShape = any>(\n  defaultSelection: FieldSelection | null,\n  response: any,\n  record: any,\n  hasReturnType?: boolean | null\n) => {\n  // Delete actions have a null selection. We do an early return for this because `hydrateRecordArray` will fail\n  // if there's nothing at `mutationResult[modelSelectionField]`, but the caller isn't expecting a return (void).\n  if (defaultSelection == null) return;\n  if (!hasReturnType) {\n    return hydrateRecord<Shape>(response, record);\n  } else {\n    return record.result;\n  }\n};\n\nexport const globalActionRunner = async (\n  connection: GadgetConnection,\n  operation: string,\n  variables: VariablesOptions,\n  namespace?: string | null\n) => {\n  const plan = globalActionOperation(operation, variables, namespace);\n  const response = await connection.currentClient.mutation(plan.query, plan.variables).toPromise();\n  const dataPath = namespace ? [namespace, operation] : [operation];\n  return assertMutationSuccess(response, dataPath).result;\n};\n\nexport const enqueueActionRunner = async <Action extends AnyActionFunction>(\n  connection: GadgetConnection,\n  action: Action,\n  variables: Action[\"variablesType\"],\n  options: EnqueueBackgroundActionOptions<Action> = {}\n) => {\n  const normalizedVariableValues =\n    \"isBulk\" in action && action.isBulk\n      ? disambiguateBulkActionVariables(action, variables)\n      : disambiguateActionVariables(action, variables);\n  const variableOptions = setVariableOptionValues(action.variables, normalizedVariableValues);\n\n  const plan = enqueueActionOperation(action.operationName, variableOptions, action.namespace, options);\n  const response = await connection.currentClient.mutation(plan.query, plan.variables, options).toPromise();\n  const dataPath = [\"background\", action.operationName];\n  if (action.namespace) {\n    dataPath.unshift(action.namespace);\n  }\n\n  try {\n    const result = assertMutationSuccess(response, dataPath);\n    return new BackgroundActionHandle(connection, action, result.backgroundAction.id, options);\n  } catch (error: any) {\n    if (\"code\" in error && error.code == \"GGT_DUPLICATE_BACKGROUND_ACTION_ID\" && options?.id && options.onDuplicateID == \"ignore\") {\n      return new BackgroundActionHandle(connection, action, options.id, options);\n    }\n    throw error;\n  }\n};\n\nexport const actionResultRunner = async <Action extends AnyActionFunction, Options extends ActionFunctionOptions<Action>>(\n  connection: GadgetConnection,\n  id: string,\n  action: Action,\n  options?: Options\n): Promise<BackgroundActionResult> => {\n  const plan = actionResultOperation(id, action, options);\n  const subscription = connection.currentClient.subscription(plan.query, plan.variables);\n\n  const response = await pipe(\n    subscription,\n    filter((operation) => operation.error || operation.data?.backgroundAction?.outcome),\n    take(1),\n    toPromise\n  );\n\n  const backgroundAction = assertOperationSuccess(response, [\"backgroundAction\"]);\n\n  assertResponseSuccess(backgroundAction.result);\n\n  switch (action.type) {\n    case \"action\": {\n      backgroundAction.result = processActionResponse(\n        action.defaultSelection,\n        response.data,\n        get(backgroundAction.result, [action.modelSelectionField]),\n        action.hasReturnType\n      );\n      break;\n    }\n    case \"globalAction\": {\n      backgroundAction.result = backgroundAction.result.result;\n      break;\n    }\n  }\n\n  return backgroundAction;\n};\n"]}